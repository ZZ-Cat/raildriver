#[
    This file is a part of the RailDriver project.
    Copyright Â© 2022, Cassandra "ZZ Cat" Robinson. All rights reserved.
]#

@name RailDriver/lib/pid
#include "e2shared/RailDriver/lib/timers"

function table pidCreateInstance()
{
    local S = table()
    S:clear()

    # Default properties:
    S["Sample Time", number] = ticksToMillis(1)
    S["Range", number] = 75000
    S["Scale", number] = 100
    S["Proportional", number] = 1012
    S["Integral", number] = 850
    S["Derivative", number] = 10
    S["Feed Forward", number] = 14
    S["Proportional Mode", number] = 0
    S["Direction", number] = 1
    S["Mode", number] = 1

    # Default CV properties:
    S["CV Floor", number] = -75000
    S["CV Ceiling", number] = 75000

    # Default I-Term limit properties:
    S["Use I-Term Limit", number] = 1
    S["I-Term Limit Max", number] = 75000
    S["I-Term Limit Min", number] = -75000

    # Default I-Term decay properties:
    S["Use I-Term Decay", number] = 1
    S["I-Term Decay Time Millis", number] = 2000
    S["I-Term Decay SP Threshold", number] = 0
    S["I-Term Decay PV Threshold", number] = 8.0
    S["I-Term Decay PV Hysteresis", number] = (2/100)*S["I-Term Decay PV Threshold", number]

    # Primary variables:
    S["Set Point", number] = 0
    S["Process Variable", number] = 0
    S["Control Variable", number] = 0

    # Feedforward Gains:
    S["Acceleration Feedforward", number] = 0
    S["Yaw Rate Feedforward", number] = 0
    S["Pitch Angle Feedforward", number] = 0
    S["Throttle Feedforward", number] = 0
    S["Brake Feedforward", number] = 0

    # Internal Gains:
    S["Internal P Gain", number] = 0
    S["Internal I Gain", number] = 0
    S["Internal D Gain", number] = 0
    S["Internal FF Accel", number] = 0
    S["Internal FF Yaw Rate", number] = 0
    S["Internal FF Pit Ang", number] = 0
    S["Internal FF Thr", number] = 0
    S["Internal FF Brk", number] = 0

    # Last known variables:
    S["Last Time", number] = 0
    S["Last Process Variable", number] = 0

    # Control Variable summing bus:
    S["P-Term", number] = 0
    S["I-Term", number] = 0
    S["D-Term", number] = 0
    S["FF Accel", number] = 0
    S["FF Yaw Rate", number] = 0
    S["FF Pit Ang", number] = 0
    S["FF Thr", number] = 0
    S["FF Brk", number] = 0
    S["FF Sum", number] = 0
    S["CV Sum", number] = 0

    # Return the PID table that was created.
    return S
}

function number pidSetControlVariableLimits(S:table, Floor, Ceiling)
{
    if (Floor > Ceiling)
    {
        return 0
    }

    else
    {
        S["CV Floor", number] = Floor
        S["CV Ceiling", number] = Ceiling

        if (S["Mode", string] != "automatic")
        {
            return 0
        }

        S["Control Variable", number] = clamp(S["Control Variable", number], Floor, Ceiling)
        # S["CV Sum", number] = clamp(S["CV Sum", number], Floor, Ceiling)
        return 1
    }
}

function number pidSetProportionalMode(S:table, PMode:string)
{
    PMode:lower()
    switch (PMode)
    {
        case "error",
        case "proportional on error",
            S["Proportional Mode", number] = 0
            return 1
        break

        case "measure",
        case "measurement",
        case "proportional on measurement",
        case "proportional on measure",
            S["Proportional Mode", number] = 1
            return 1
        break

        default,
            return 0
        break
    }
}

function number pidSetGains(S:table, Gains:string, Value)
{
    local MillisToSeconds = S["Sample Time", number] / 1000
    Gains:lower()
    switch (Gains)
    {
        case "proportional",
            S["Proportional", number] = Value
            S["Internal P Gain", number] = S["Proportional", number] * S["Scale", number]
            return S["Proportional", number]
        break

        case "integral",
            S["Integral", number] = Value
            S["Internal I Gain", number] = (S["Integral", number] * S["Scale", number]) * MillisToSeconds
            return S["Integral", number]
        break
        
        case "derivative",
            S["Derivative", number] = Value
            S["Internal D Gain", number] = (S["Derivative", number] * S["Scale", number]) / MillisToSeconds
            return S["Derivative", number]
        break

        case "acceleration feedforward",
            S["Acceleration Feedforward", number] = Value * S["Scale", number]
            S["Internal FF Accel", number] = S["Acceleration Feedforward", number]
            return S["Internal FF Accel", number]
        break

        case "yaw rate feedforward",
            S["Yaw Rate Feedforward", number] = Value
            S["Internal FF Yaw Rate", number] = S["Yaw Rate Feedforward", number] * S["Scale", number]
            return S["Yaw Rate Feedforward", number]
        break

        case "pitch angle feedforward",
            S["Pitch Angle Feedforward", number] = Value
            S["Internal FF Pitch Angle", number] = S["Pitch Angle Feedforward", number] * S["Scale", number]
            return S["Pitch Angle Feedforward", number]
        break

        case "throttle feedforward",
            S["Throttle Feedforward", number] = Value
            S["Internal FF Thr", number] = S["Throttle Feedforward", number] * S["Scale", number]
            return S["Throttle Feedforward", number]
        break

        case "brake feedforward",
            S["Brake Feedforward", number] = Value
            S["Internal FF Brk", number] = S["Brake Feedforward", number] * S["Scale", number]
            return S["Brake Feedforward", number]
        break

        default,
            return 0
        break
    }
}

function number pidSetGains(S:table, PtermGain, ItermGain, DtermGain)
{
    if (pidSetGains(S, "proportional", PtermGain) == 0)
    {
        return 0
    }

    if (pidSetGains(S, "integral", ItermGain) == 0)
    {
        return 0
    }

    if (pidSetGains(S, "derivative", DtermGain) == 0)
    {
        return 0
    }

    return 1
}

function number pidSetFeedforward(S:table, FFaccel, FFyawRate, FFpitchAngle, FFthr, FFbrk)
{
    if (pidSetGains(S, "acceleration feedforward", FFaccel) == 0)
    {
        return 0
    }

    if (pidSetGains(S, "yaw rate feedforward", FFyawRate) == 0)
    {
        return 0
    }

    if (pidSetGains(S, "pitch angle feedforward", FFpitchAngle) == 0)
    {
        return 0
    }

    if (pidSetGains(S, "throttle feedforward", FFthr) == 0)
    {
        return 0
    }

    if (pidSetGains(S, "brake feedforward", FFbrk) == 0)
    {
        return 0
    }

    return 1
}

function number pidSetSampleTime(S:table, T)
{
    if (T <= 0)
    {
        return 0
    }

    local GetRatioedMotherfucker = T/S["Sample Time", number]
    local Ki = S["Internal I Gain", number]
    local Kd = S["Internal D Gain", number]

    Ki *= GetRatioedMotherfucker
    Kd /= GetRatioedMotherfucker

    S["Internal I Gain", number] = Ki
    S["Internal D Gain", number] = Kd
    S["Sample Time", number] = T

    return S["Sample Time", number]
}

function number pidInitialize(S:table)
{
    S["Last Process Variable", number] = S["Process Variable", number]
    S["Control Variable", number] = clamp(S["Control Variable", number], S["CV Floor", number], S["CV Ceiling", number])
    return 1
}

function number pidSetMode(S:table, M:string)
{
    M:lower()
    switch(M)
    {
        case "manual",
            S["Mode", number] = 0
            return 1
        break

        case "automatic",
            if (S["Mode", number] == 0)
            {
                pidInitialize(PID)
            }
            S["Mode", number] = 1
            return 1
        break

        default,
            return 0
        break
    }
}

function void pidUpdate(S:table)
{
    # PID Controller can have several operating modes.
    # These modes can include, but aren't limited to:
    #   > Manual Mode.
    #       In this mode, all PID tunings are set extremely low, so that the control loop is only correcting for residual disturbances.
    #       Feedforward is heavily manipulated in order to provide you with a traditional locomotive engineering experience.
    #       If you're experienced with Garry's Mod Train Build & train simulators in general, use this mode.
    #   > Throttle Mode.
    #       This is similar to Manual Mode. But, with a twist.
    #       Instead of controlling torque, you're controlling how quickly/slowly the locomotive will accelerate or decelerate to your
    #       desired speed.
    #       The higher you set your throttle, the faster the locomotive will accelerate.
    #       Deceleration is controlled by operating the brake lever. Again, this is similar to traditional braking.
    #       Speed is only held when both the throttle & brake levers are in their neutral positions.
    #       I-Term Decay is heavily leveraged in this mode to prevent the locomotive from rolling backwards & winding up the control
    #       loop.
    #   > Speed Hold Mode.
    #       This mode can be thought of as Cruise Control, as it is the most simplest & most beginner/user-friendly mode.
    #       Use this mode if you're new to Garry's Mod Train Build or you just want to quickly get on the tracks & run without any
    #       hassles.
    #       Your throttle lever is controlling what speed your locomotive will travel at, instead of controlling torque or acceleration.
    #       To increase speed, simply move the throttle lever up one notch & leave it there.
    #       To decrease speed, simply move the throttle lever down one notch & leave it there.
    #       To stop completely, simply move the throttle lever to its neutral position.
    #       The Control Loop will do all of the heavy lifting for you & it will keep the locomotive locked to your desired speed,
    #       regardless of the railroad conditions.
    #       Climbing or descending hills? Not a problem!
    #       Going around corners? Not a problem!
    #       Doing a coupler approach at a slow speed? Not a problem!
    # 
    # Keep in mind that the speed settings in Speed Hold Mode are dependent on what map you're driving on.
    # In any mode, you will not be allowed to drive faster than the posted line speed limit.
    # There are legit safety checks in RailDriver that prevent you from doing this.
    # The control loop is also supervised by an observer that monitors the performance of the PID controller itself.
    # The observer will enact safety protocols on a case-by-case basis, if something goes awry.

    if (S["Mode", number] == 0)
    {
        return
    }

    local Now = millis()
    local TimeDelta = Now - S["Last Time", number]

    # PID needs a lot of processing power for its real-time requirements.
    if (TimeDelta >= S["Sample Time", number])
    {
        # TODO: Measure Process Variable - This will happen elsewhere. NOT in the main PID Control Loop.
        #       The process being measured is the locomotive's speed.
        #       Speed data comes from the speed counter that's mounted to one of the trucks' bearings.

        # Calculate Error from Set Point & Process Variable delta.
        local Error = S["Set Point", number] - S["Process Variable", number]

        # Calculate I-Term.
        local PVdelta = S["Process Variable", number] - S["Last Process Variable", number]
        local Iterm = S["I-Term", number]
        Iterm += (S["Internal I Gain", number] * Error)
        S["I-Term", number] = Iterm

        # Calculate Proportional on Measurement, if specified.
        if (S["Proportional Mode", number] == 1)
        {
            S["P-Term", number] = S["Internal P Gain", number] * PVdelta
            S["I-Term", number] -= S["P-Term", number]
        }

        # Calculate & apply I-Term Limit.
        # This limits the buildup of Integral, to help stave off windup.
        if (S["Use I-Term Limit", number] != 0)
        {
            S["I-Term", number] = clamp(S["I-Term", number], S["I-Term Limit Min", number], S["I-Term Limit Max", number])
        }

        # Calculate Proportional on Error, if specified.
        if (S["Proportional Mode", number] == 0)
        {
            S["P-Term", number] = S["Internal P Gain", number] * Error
            S["CV Sum", number] = S["P-Term", number]
        }

        else
        {
            S["CV Sum", number] = 0
        }

        # TODO: Calculate & apply I-Term Relax.
        #         I-Term Relax will benefit the locomotive when it's on flat & level sections of track, or other situations where
        #         the Control Loop does not need to be as reactive.
        # TODO: Calculate & apply I-Term Decay.
        #         This will bleed off the I-Term when the locomotive is decelerating to a full stop.
        #         My theory with this is, it will help with preventing the locomotive from rolling backwards.
        #         When this happens, the I-Term has already wound back in the opposite direction from slowing the locomotive down.
        #         But, the Control Loop hasn't had time to react to the fact that the locomotive has actually stopped.
        #         The I-Term continues to wind back until it hits its lowermost limit (this is even worse, when it already has hit
        #         its lowermost limit from decelerating the train from a high speed), because the control loop still thinks that the
        #         locomotive is still moving. I mean... it's not wrong, it's just that the locomotive is now moving in the opposite
        #         direction to what the Control Loop thinks it's moving in. So, the locomotive continues to accelerate...
        #         in the opposite direction... while the Control Loop has completely wound up & hit its lowermost limits.
        #         If the locomotive is allowed to continue accelerating like this, it will do it to the point of derailing & causing
        #         total destruction. I have been piloting a 1200 ton train when this has happened & it is not fun. ='^/,..,^=
        #         I-Term Decay stops this from happening, by bleeding off the accumulated I-Term when the Set Point has been set to 0
        #         & the Process Variable crosses a threshold that's close to the locomotive's actual stopping speed.

        # Calculate D-Term.
        S["D-Term", number] = S["I-Term", number] - S["Internal D Gain", number] * PVdelta
        S["CV Sum", number] += S["D-Term", number]

        # TODO: Calculate Feedforward - This may come from several sources. This can include, but isn't limited to:
        #       > Acceleration Data (taken from an accelerometer).
        #           This is useful for aiding the control loop with accelerating the locomotive to the desired Set Point.
        #           This will only be available when a change in Set Point has been detected.
        #       > Rotation Rate Data (taken from a gyroscope).
        #           This will aid in cornering stability.
        #       > Orientation Data (taken from an inclinometer).
        #           This will aid the locomotive in climbing & descending hills.
        #           As the hill gets steeper, more feedforward will be applied.
        #       > Trailing weight?
        #           This is something that I want to explore, at some point.
        #           Factoring the locomotive's trailing weight into the feedforward.
        # 
        # Traditional Set Point based feedforward is used for the time being.
        S["FF Thr", number] = S["Internal FF Thr", number] * S["Set Point", number]
        S["FF Sum", number] = S["FF Thr", number]
        S["CV Sum", number] += S["FF Sum", number]

        # Apply a limit to the Control Variable.
        S["CV Sum", number] = clamp(S["CV Sum", number], S["CV Floor", number], S["CV Ceiling", number])
        S["Control Variable", number] = S["CV Sum", number]

        # Store a couple of variables for use in the next execution.
        S["Last Process Variable", number] = S["Process Variable", number]
        S["Last Time", number] = Now

    }
}
